"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var crypto_1 = require("crypto");
var BN = require('bn.js');
var EC = require('elliptic').ec;
// Unfortunately, elliptic uses BN.JS, that does not support
// Euclidean modulo operations. So we need to include BigNumber.js
// as well.
var BigNumber = require('bignumber.js');
var BigNumberEuclid = BigNumber.clone({ MODULO_MODE: 9 });
// Create and initialize EC context
// (better do it once and reuse it)
var ec = new EC('secp256k1');
var DlcOracle = /** @class */ (function () {
    function DlcOracle() {
    }
    DlcOracle.generateNumericMessage = function (value) {
        var numberString = value.toString(16);
        numberString = new Array(64 - numberString.length + 1).join('0') + numberString;
        return Buffer.from(numberString, 'hex');
    };
    DlcOracle.publicKeyFromPrivateKey = function (privateKey) {
        var keyPair = ec.keyFromPrivate(privateKey);
        return Buffer.from(keyPair.getPublic(true, 'hex'), 'hex');
    };
    DlcOracle.generateOneTimeSigningKey = function () {
        return crypto_1.randomBytes(32);
    };
    DlcOracle.computeSignaturePubKey = function (oracleA, oracleR, message) {
        var A = ec.keyFromPublic(oracleA);
        var R = ec.keyFromPublic(oracleR);
        var e = crypto_1.createHash('sha256');
        e.update(message);
        e.update(oracleR);
        var bigE = new BN(e.digest('hex'), 16);
        var P = A.pub.mul(bigE);
        var bigY = new BigNumberEuclid(P.getY().toString(16), 16);
        bigY = bigY.negated();
        bigY = bigY.mod(ec.curve.p);
        var newY = new BN(bigY.toString(16), 16);
        P = ec.curve.point(P.getX(), newY);
        P = P.add(R.pub);
        return Buffer.from(P.encodeCompressed('hex'), 'hex');
    };
    DlcOracle.computeSignature = function (privateKey, oneTimeSigningKey, message) {
        var bigPriv = new BN(privateKey.toString('hex'), 16);
        var bigK = new BN(oneTimeSigningKey.toString('hex'), 16);
        var R = ec.g.mul(bigK);
        var Rx = R.getX();
        var e = crypto_1.createHash('sha256');
        e.update(message);
        e.update(Buffer.from(Rx.toString(16), 'hex'));
        var eHex = e.digest('hex');
        var bigE = new BN(eHex, 16);
        console.log("bigE:", bigE.toString(16));
        // TODO: Check e out of range
        var bigS = new BN(bigE);
        console.log("BigS (0):", bigS.toString(16));
        bigS = bigS.mul(bigPriv);
        console.log("BigS (1):", bigS.toString(16));
        bigS = bigS.sub(bigK);
        console.log("BigS (2):", bigS.toString(16));
        console.log("n: ", ec.n.toString(16));
        var bigS2 = new BigNumberEuclid(bigS.toString(16), 16);
        console.log("BigS (2):", bigS2.toString(16));
        bigS2 = bigS2.mod(ec.n);
        console.log("BigS (3):", bigS2.toString(16));
        // TODO: Check zero
        var numberString = bigS2.toString(16);
        if (numberString.length < 64)
            numberString = new Array(64 - numberString.length + 1).join('0') + numberString;
        return Buffer.from(numberString, 'hex');
    };
    return DlcOracle;
}());
exports.DlcOracle = DlcOracle;
